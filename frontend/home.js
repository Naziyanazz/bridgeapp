const topicList = document.getElementById("topicList");
const content = document.getElementById("content");

const topics = {
   "topic1": `
   <h2 class="pt-5 lh-base mb-3">Web Development</h2>
   <p>Web development stands as one of the most dynamic and rapidly evolving fields in computer science, offering endless opportunities for creativity, innovation, and career growth. As a BTech CS student, mastering web development opens doors to countless possibilities in the digital world. The journey begins with understanding the fundamental building blocks of the web: HTML5, CSS3, and JavaScript. HTML5 provides the semantic structure and content organization, introducing powerful features like canvas elements for graphics, video and audio elements for multimedia content, and form enhancements that make user interactions more intuitive. CSS3 revolutionizes styling with advanced features like flexbox and grid layouts for responsive design, animations and transitions for engaging user experiences, and media queries that ensure your applications look perfect on any device from smartphones to large desktop monitors.</p>
   <p>JavaScript ES6+ transforms web development with modern syntax and powerful features including arrow functions, destructuring assignment, template literals, and async/await for handling asynchronous operations. The language evolution continues with modules, classes, and advanced array methods that make code more maintainable and efficient. Modern JavaScript frameworks and libraries like React, Vue.js, and Angular have revolutionized how we build user interfaces. React's component-based architecture promotes reusability and maintainability, while its virtual DOM ensures optimal performance. Vue.js offers a gentle learning curve with its intuitive template syntax and excellent documentation, making it perfect for both small projects and large-scale applications. Angular provides a comprehensive framework with TypeScript integration, dependency injection, and powerful CLI tools for enterprise-level applications.</p>
   <p>The backend ecosystem is equally fascinating, with Node.js enabling JavaScript to run on servers, creating full-stack JavaScript applications. Express.js simplifies server creation with its minimal and flexible approach, while frameworks like NestJS bring structure and scalability to larger projects. Database integration involves understanding both SQL databases like MySQL, PostgreSQL, and SQLite for structured data, and NoSQL databases like MongoDB for flexible document storage. API development includes RESTful services with proper HTTP methods, status codes, and resource organization, as well as GraphQL for more efficient data fetching with its query language that allows clients to request exactly what they need.</p>
   <p>Modern development tools enhance productivity significantly. Webpack and Vite handle module bundling and asset optimization, while package managers like npm and Yarn manage dependencies efficiently. Version control with Git becomes essential for collaboration and code management. Development environments benefit from tools like VS Code with its extensive plugin ecosystem, Chrome DevTools for debugging, and Postman for API testing. Progressive Web Apps (PWAs) bridge the gap between web and mobile applications, offering offline functionality, push notifications, and app-like experiences through service workers and web app manifests.</p>
   <p>Deployment strategies have evolved with cloud platforms making hosting accessible and scalable. AWS offers comprehensive services from simple static hosting with S3 to complex microservices with Lambda functions. Heroku provides easy deployment for full-stack applications, while Netlify and Vercel specialize in static sites and JAMstack applications. Understanding CI/CD pipelines ensures automatic testing and deployment, reducing human error and increasing development velocity. Performance optimization becomes crucial as applications grow, involving code splitting, lazy loading, image optimization, and CDN usage to ensure fast loading times across global audiences.</p>
 `,
 "topic2": `
   <h2 class="pt-5 lh-base mb-3">Data Structures & Algorithms</h2>
   <p>Data Structures and Algorithms form the backbone of computer science and software engineering, representing the fundamental concepts that every BTech CS student must master to become a proficient programmer and problem solver. This subject goes far beyond academic learning; it's the foundation upon which all efficient software is built. Understanding data structures begins with arrays, the simplest yet most versatile structure that stores elements in contiguous memory locations, enabling constant-time access but requiring linear time for insertion and deletion in the middle. Dynamic arrays or vectors overcome size limitations, automatically resizing as needed while maintaining most performance characteristics. Linked lists introduce the concept of non-contiguous memory storage, where elements connect through pointers, enabling efficient insertion and deletion at any position but sacrificing random access capabilities.</p>
   <p>Stack and queue structures implement specific access patterns that mirror real-world scenarios. Stacks follow Last-In-First-Out (LIFO) principle, essential for function call management, expression evaluation, and backtracking algorithms. Queues implement First-In-First-Out (FIFO) ordering, crucial for breadth-first search, task scheduling, and buffer management in operating systems. Advanced variations like circular queues, priority queues, and deques extend basic functionality for specialized applications. Trees represent hierarchical data naturally, with binary trees serving as the foundation for more complex structures. Binary Search Trees (BST) maintain sorted order while allowing logarithmic search, insertion, and deletion operations in average cases. Self-balancing trees like AVL trees and Red-Black trees guarantee logarithmic performance in worst-case scenarios, essential for database indexing and compiler symbol tables.</p>
   <p>Hash tables revolutionize data access with near-constant time operations through clever use of hash functions that map keys to array indices. Understanding collision resolution techniques like chaining and open addressing becomes crucial for implementing efficient hash tables. Graphs represent complex relationships between entities, with applications ranging from social networks to GPS navigation systems. Graph representations through adjacency matrices and adjacency lists each offer different trade-offs between space complexity and operation efficiency. Graph algorithms like Dijkstra's shortest path, Kruskal's minimum spanning tree, and topological sorting solve real-world problems in network routing, circuit design, and project scheduling.</p>
   <p>Sorting algorithms demonstrate various problem-solving approaches and complexity trade-offs. Simple algorithms like bubble sort and insertion sort teach basic concepts but scale poorly, while efficient algorithms like merge sort and quick sort showcase divide-and-conquer strategies. Heap sort introduces the heap data structure, essential for priority queues and efficient selection algorithms. Radix sort and counting sort demonstrate that comparison-based sorting isn't always optimal, achieving linear time complexity under specific conditions. Searching algorithms extend beyond simple linear and binary search to include techniques like interpolation search for uniformly distributed data and exponential search for unbounded arrays.</p>
   <p>Dynamic programming transforms complex problems into manageable subproblems, teaching the art of optimization through memoization and tabulation. Classic problems like the knapsack problem, longest common subsequence, and edit distance demonstrate how breaking problems into smaller, overlapping subproblems leads to efficient solutions. Greedy algorithms offer another optimization strategy, making locally optimal choices to achieve global optimization in problems like activity selection, Huffman coding, and coin change. Algorithm analysis through Big O notation provides the mathematical framework for comparing algorithm efficiency, considering time and space complexity across best, average, and worst-case scenarios. This knowledge becomes invaluable during technical interviews at top technology companies and forms the foundation for advanced topics like machine learning algorithms, database optimization, and system design.</p>
 `,
 "topic3": `
   <h2 class="pt-5 lh-base mb-3">Machine Learning & AI</h2>
   <p>Machine Learning and Artificial Intelligence represent the cutting-edge frontier of computer science, transforming industries and reshaping how we interact with technology. For BTech CS students, this field offers unprecedented opportunities to work on problems that seemed impossible just decades ago. The journey into ML begins with understanding the fundamental paradigms: supervised learning, where algorithms learn from labeled training data to make predictions on new, unseen data; unsupervised learning, which discovers hidden patterns in data without explicit labels; and reinforcement learning, where agents learn optimal actions through interaction with environments and reward signals. Supervised learning encompasses regression problems, where the goal is predicting continuous values like house prices or stock market trends, and classification problems, which involve categorizing data into discrete classes like email spam detection or medical diagnosis.</p>
   <p>The mathematical foundations underlying machine learning are crucial for deep understanding and effective implementation. Linear algebra provides the framework for data representation and transformation through vectors and matrices, while calculus enables optimization of model parameters through gradient descent and its variants. Statistics and probability theory offer the theoretical foundation for understanding uncertainty, model evaluation, and decision-making under incomplete information. Feature engineering, often considered more art than science, involves selecting, creating, and transforming input variables to improve model performance. This process requires domain expertise, creativity, and deep understanding of both the data and the problem being solved.</p>
   <p>Popular machine learning libraries have democratized access to sophisticated algorithms and tools. Scikit-learn provides an intuitive interface for traditional machine learning algorithms, offering consistent APIs for classification, regression, clustering, and dimensionality reduction. Pandas revolutionizes data manipulation and analysis with its powerful DataFrame structure, enabling efficient data cleaning, transformation, and exploration. NumPy provides the numerical computing foundation with optimized array operations and mathematical functions. For deep learning, TensorFlow and PyTorch dominate the landscape, offering both high-level APIs for rapid prototyping and low-level control for research and custom implementations.</p>
   <p>Deep learning, a subset of machine learning inspired by biological neural networks, has achieved remarkable breakthroughs in computer vision, natural language processing, and game playing. Convolutional Neural Networks (CNNs) excel at image recognition tasks, learning hierarchical feature representations that capture patterns from simple edges to complex objects. Recurrent Neural Networks (RNNs) and their advanced variants like LSTMs and GRUs process sequential data, enabling applications in machine translation, speech recognition, and time series forecasting. Transformer architectures have revolutionized natural language processing, leading to powerful models like BERT, GPT, and their successors that demonstrate human-like language understanding and generation capabilities.</p>
   <p>Computer vision applications extend far beyond simple image classification to include object detection, semantic segmentation, and image generation. Object detection algorithms like YOLO and R-CNN can locate and classify multiple objects within images in real-time, enabling autonomous vehicles, surveillance systems, and augmented reality applications. Generative models like Generative Adversarial Networks (GANs) and Variational Autoencoders (VAEs) create new data samples, leading to applications in art generation, data augmentation, and synthetic data creation. Natural Language Processing encompasses tasks from basic text classification and sentiment analysis to advanced applications like question answering, text summarization, and dialogue systems. The ethical implications of AI systems become increasingly important as these technologies integrate into society, requiring consideration of bias, fairness, transparency, and accountability in algorithmic decision-making.</p>
 `,
 "topic4": `
   <h2 class="pt-5 lh-base mb-3">Database Management Systems</h2>
   <p>Database Management Systems serve as the backbone of modern information systems, providing structured, efficient, and secure methods for storing, retrieving, and managing vast amounts of data that power everything from small web applications to enterprise-scale systems. For BTech CS students, mastering DBMS concepts is essential as virtually every software application requires persistent data storage and management. The journey begins with understanding the relational model, introduced by Edgar Codd, which organizes data into tables (relations) with rows (tuples) and columns (attributes). This model provides a mathematical foundation for data organization and manipulation, ensuring data integrity through concepts like primary keys, foreign keys, and referential integrity constraints. The relational model's power lies in its simplicity and flexibility, allowing complex queries through a declarative language like SQL while maintaining data consistency and reducing redundancy through normalization techniques.</p>
   <p>SQL (Structured Query Language) serves as the universal language for relational databases, providing powerful capabilities for data definition, manipulation, and querying. DDL (Data Definition Language) commands like CREATE, ALTER, and DROP manage database schema, defining tables, indexes, and constraints that enforce business rules and data integrity. DML (Data Manipulation Language) operations including SELECT, INSERT, UPDATE, and DELETE enable comprehensive data management. Advanced SQL features like joins enable complex queries across multiple tables, window functions provide analytical capabilities, and stored procedures encapsulate business logic within the database. Query optimization becomes crucial as databases grow, involving understanding execution plans, index usage, and query restructuring for optimal performance.</p>
   <p>Database design principles guide the creation of efficient and maintainable systems. The Entity-Relationship (ER) model provides a conceptual framework for understanding data relationships, translating real-world requirements into database structures. Normalization theory, progressing through normal forms (1NF, 2NF, 3NF, BCNF), eliminates data redundancy and update anomalies while sometimes requiring denormalization for performance optimization. Indexing strategies dramatically impact query performance, with B-tree indexes serving most general purposes while specialized indexes like bitmap indexes for low-cardinality data and full-text indexes for text search address specific needs. Understanding when and how to create indexes requires balancing query performance against storage overhead and update costs.</p>
   <p>Transaction management ensures data consistency and reliability in concurrent environments through ACID properties: Atomicity guarantees that transactions complete entirely or not at all; Consistency ensures that transactions maintain database validity rules; Isolation prevents concurrent transactions from interfering with each other; and Durability guarantees that committed changes persist even in case of system failures. Concurrency control mechanisms like locking protocols, timestamp ordering, and multiversion concurrency control enable multiple users to access the database simultaneously while maintaining consistency. Recovery mechanisms protect against system failures through techniques like write-ahead logging, checkpointing, and backup strategies.</p>
   <p>The NoSQL revolution addresses limitations of traditional relational databases in handling massive scale, flexible schemas, and distributed architectures. Document databases like MongoDB store data in flexible, JSON-like documents, ideal for content management and catalogs. Key-value stores like Redis provide ultra-fast access for caching and session management. Column-family databases like Cassandra excel at handling time-series data and large-scale analytical workloads. Graph databases like Neo4j naturally represent and query complex relationships, perfect for social networks and recommendation systems. Modern database architectures embrace distributed systems concepts, with technologies like database sharding, replication, and eventual consistency enabling global-scale applications. Cloud database services from AWS, Google Cloud, and Microsoft Azure provide managed database solutions that handle scaling, backup, and maintenance automatically, allowing developers to focus on application logic rather than database administration. Understanding when to choose SQL versus NoSQL, and which specific database technology fits particular use cases, becomes a crucial skill for modern software architects.</p>
 `,
 "topic5": `
   <h2 class="pt-5 lh-base mb-3">Software Engineering</h2>
   <p>Software Engineering represents the systematic approach to designing, developing, and maintaining large-scale software systems, transforming programming from an art into a disciplined engineering practice. For BTech CS students, understanding software engineering principles is crucial for building robust, scalable, and maintainable applications that can evolve with changing requirements and handle real-world complexities. The Software Development Life Cycle (SDLC) provides structured methodologies for managing software projects from conception to deployment and maintenance. Traditional waterfall models offer predictable phases including requirements analysis, system design, implementation, testing, deployment, and maintenance, suitable for projects with well-defined, stable requirements. However, modern software development increasingly favors agile methodologies that embrace change and iterative development.</p>
   <p>Agile frameworks like Scrum and Kanban revolutionize project management by emphasizing collaboration, flexibility, and rapid delivery of working software. Scrum organizes work into time-boxed sprints, typically lasting 2-4 weeks, with defined roles including Product Owner, Scrum Master, and Development Team. Daily stand-ups, sprint planning, sprint reviews, and retrospectives ensure continuous communication and improvement. User stories capture requirements from the end-user perspective, breaking down complex features into manageable, testable increments. Kanban visualizes workflow through boards and cards, optimizing for continuous delivery and reducing work-in-progress bottlenecks. These methodologies require cultural shifts toward transparency, trust, and adaptive planning rather than rigid adherence to initial specifications.</p>
   <p>Version control systems, particularly Git, form the foundation of collaborative software development. Git's distributed architecture enables multiple developers to work simultaneously on the same codebase while maintaining complete history and enabling sophisticated merging strategies. Branching strategies like Git Flow organize development work, with master branches containing production-ready code, develop branches for integration, and feature branches for individual development tasks. Pull requests or merge requests facilitate code review processes, ensuring quality and knowledge sharing across team members. Platforms like GitHub, GitLab, and Bitbucket extend Git functionality with issue tracking, project management, and continuous integration capabilities.</p>
  
 `,
 "topic6": `
   <h2 class="pt-5 lh-base mb-3">Mobile App Development</h2>
   <p>Mobile App Development has become one of the most dynamic and lucrative fields in software engineering, driven by the ubiquity of smartphones and tablets in modern life. For BTech CS students, mobile development offers exciting opportunities to create applications that reach billions of users worldwide while leveraging unique device capabilities like GPS, cameras, sensors, and touch interfaces. The mobile ecosystem is primarily divided between Android and iOS platforms, each with distinct development approaches, programming languages, and design philosophies. Android development traditionally uses Java or Kotlin within Android Studio IDE, leveraging the rich Android SDK that provides access to device features and Google services. iOS development employs Swift or Objective-C within Xcode, utilizing Apple's comprehensive frameworks and adhering to strict App Store guidelines and Human Interface Guidelines.</p>
   <p>Native Android development with Kotlin offers modern language features including null safety, extension functions, and coroutines for asynchronous programming. The Android architecture follows the Activity and Fragment lifecycle, managing application states and user interface components through various lifecycle callbacks. Material Design principles guide user interface creation, providing consistent visual language through components like CardView, RecyclerView, and Navigation Components. Android's flexible layout system supports various screen sizes and orientations through responsive design techniques using ConstraintLayout, LinearLayout, and RelativeLayout. Data persistence options include SQLite databases, Room persistence library for type-safe database access, and SharedPreferences for simple key-value storage. Background processing utilizes Services, WorkManager for deferrable tasks, and BroadcastReceivers for system events.</p>
   <p>iOS development with Swift embraces Apple's ecosystem philosophy of seamless integration and premium user experience. The iOS architecture centers around View Controllers and the delegate pattern, managing application flow through segues and navigation controllers. SwiftUI, Apple's modern declarative framework, revolutionizes iOS development with reactive programming principles and cross-platform compatibility with macOS, watchOS, and tvOS. UIKit remains essential for complex custom interfaces and legacy compatibility. Core Data provides powerful object-relational mapping for data persistence, while CloudKit enables seamless synchronization across user devices. iOS development emphasizes performance optimization, memory management through Automatic Reference Counting (ARC), and adherence to Apple's strict security and privacy requirements.</p>
   <p>Cross-platform development frameworks address the challenge of maintaining separate codebases for different platforms. React Native leverages JavaScript and React concepts to build native mobile applications, sharing significant code between iOS and Android while maintaining native performance and look-and-feel. Facebook's creation enables web developers to transition into mobile development using familiar technologies, with hot reloading capabilities that accelerate development cycles. Flutter, Google's UI toolkit, uses Dart programming language to create natively compiled applications with a single codebase. Flutter's widget-based architecture and custom rendering engine provide pixel-perfect consistency across platforms, making it particularly attractive for applications requiring identical user experiences. Xamarin enables C# developers to create cross-platform applications while sharing business logic and accessing native APIs through platform-specific implementations.</p>
   <p>Mobile app architecture patterns ensure scalable and maintainable applications as complexity grows. Model-View-ViewModel (MVVM) pattern separates user interface logic from business logic, particularly popular in Android development with Architecture Components like LiveData and ViewModel. Clean Architecture principles create layered applications with clear separation of concerns, dependency inversion, and testability. State management becomes crucial in complex applications, with solutions like Redux for React Native, BLoC pattern for Flutter, and various state management libraries for native development. API integration requires understanding RESTful services, GraphQL queries, authentication mechanisms, and offline-first architectures that provide seamless user experiences regardless of network connectivity. Performance optimization involves understanding memory management, efficient image loading, lazy loading techniques, and profiling tools specific to each platform. The mobile development lifecycle includes unique considerations like app store optimization (ASO), beta testing through TestFlight or Google Play Console, handling different device capabilities and screen sizes, and implementing analytics and crash reporting for production applications.</p>
 `,
 "topic7": `
   <h2 class="pt-5 lh-base mb-3">Cloud Computing & DevOps</h2>
   <p>Cloud Computing and DevOps represent a paradigm shift in how software is developed, deployed, and operated, transforming traditional IT infrastructure and development practices into scalable, automated, and efficient systems. For BTech CS students, mastering these technologies is essential as modern software development increasingly relies on cloud platforms and automation for competitive advantage. Cloud computing fundamentals begin with understanding service models: Infrastructure as a Service (IaaS) provides virtualized computing resources including servers, storage, and networking; Platform as a Service (PaaS) offers development platforms and runtime environments; and Software as a Service (SaaS) delivers complete applications over the internet. Major cloud providers like Amazon Web Services (AWS), Google Cloud Platform (GCP), and Microsoft Azure dominate the market, each offering comprehensive ecosystems of services ranging from basic compute instances to advanced machine learning and analytics platforms.</p>
   <p>Amazon Web Services, the market leader, provides an extensive catalog of services that enable virtually any computing workload. EC2 (Elastic Compute Cloud) offers scalable virtual machines with various instance types optimized for different use cases, from general-purpose computing to memory-intensive applications and GPU-accelerated workloads. S3 (Simple Storage Service) provides object storage with multiple storage classes for different access patterns and cost optimization. RDS (Relational Database Service) manages popular database engines like MySQL, PostgreSQL, and Oracle with automated backups, patching, and scaling. Lambda enables serverless computing, executing code in response to events without managing servers, perfect for microservices architectures and event-driven applications. AWS networking services including VPC (Virtual Private Cloud), CloudFront CDN, and Route 53 DNS provide secure, high-performance connectivity and content delivery.</p>
   <p>Containerization technology, led by Docker, revolutionizes application packaging and deployment by encapsulating applications and their dependencies into lightweight, portable containers. Docker containers solve the "works on my machine" problem by ensuring consistent environments from development through production. Container images built through Dockerfiles provide version-controlled, immutable application packages that can be deployed anywhere Docker runs. Container orchestration platforms like Kubernetes manage containerized applications at scale, providing features like automatic scaling, rolling updates, service discovery, and health monitoring. Kubernetes abstracts infrastructure complexity through declarative configuration, allowing developers to describe desired application state while the platform handles deployment and management details.</p>
   <p>Infrastructure as Code (IaC) treats infrastructure configuration as software, enabling version control, testing, and automation of infrastructure provisioning. Terraform, the leading IaC tool, uses declarative configuration files to define cloud resources across multiple providers, supporting complex dependencies and state management. AWS CloudFormation provides native IaC capabilities for AWS resources, while tools like Ansible and Puppet handle configuration management and application deployment. IaC enables consistent, repeatable infrastructure deployments while reducing human error and configuration drift between environments.</p>
   <p>DevOps cultural transformation emphasizes collaboration between development and operations teams, breaking down traditional silos to enable faster, more reliable software delivery. Continuous Integration (CI) practices involve frequent code commits to shared repositories, with automated builds and tests providing rapid feedback on code changes. Continuous Deployment (CD) extends CI by automatically deploying successful builds to production environments, enabling rapid feature delivery and bug fixes. CI/CD pipelines orchestrate the entire software delivery process from code commit to production deployment, incorporating automated testing, security scanning, and approval workflows. Popular CI/CD tools include Jenkins for on-premise installations, GitLab CI for integrated source control and CI/CD, GitHub Actions for GitHub-hosted projects, and cloud-native solutions like AWS CodePipeline and Google Cloud Build. Monitoring and observability become crucial in distributed systems, with tools like Prometheus, Grafana, and ELK Stack (Elasticsearch, Logstash, Kibana) providing insights into application performance, infrastructure health, and user behavior. Modern DevOps practices embrace microservices architectures, immutable infrastructure, and chaos engineering principles that proactively test system resilience through controlled failure injection.</p>
 `,
 "topic8": `
   <h2 class="pt-5 lh-base mb-3">Cybersecurity & Ethical Hacking</h2>
   <p>Cybersecurity has emerged as one of the most critical and rapidly growing fields in computer science, driven by the increasing digitization of our world and the sophisticated nature of modern cyber threats. For BTech CS students, cybersecurity offers exciting career opportunities in protecting digital assets, investigating cyber crimes, and building secure systems that can withstand malicious attacks. The field encompasses multiple domains including network security, application security, information security, and operational security. Understanding the fundamentals begins with recognizing the CIA triad: Confidentiality ensures that sensitive information remains accessible only to authorized individuals; Integrity guarantees that data remains accurate and unaltered during transmission and storage; and Availability ensures that systems and data remain accessible to legitimate users when needed.</p>
   <p>Network security forms the first line of defense against cyber attacks, involving the implementation of firewalls, intrusion detection systems (IDS), and intrusion prevention systems (IPS) to monitor and control network traffic. Understanding network protocols like TCP/IP, HTTP/HTTPS, DNS, and SMTP becomes crucial for identifying vulnerabilities and implementing proper security measures. VPNs (Virtual Private Networks) create secure tunnels for remote access, while network segmentation isolates critical systems from potential threats. Wireless security protocols like WPA3, WEP vulnerabilities, and rogue access point detection protect against unauthorized network access. Network scanning tools like Nmap, Wireshark for packet analysis, and vulnerability scanners help identify potential security weaknesses before malicious actors can exploit them.</p>
   <p>Application security focuses on securing software applications throughout their development lifecycle, implementing practices like secure coding standards, input validation, output encoding, and proper authentication mechanisms. Common vulnerabilities include SQL injection attacks that manipulate database queries, Cross-Site Scripting (XSS) that injects malicious scripts into web applications, Cross-Site Request Forgery (CSRF) that tricks users into performing unwanted actions, and buffer overflow attacks that exploit memory management weaknesses. The OWASP Top 10 provides a comprehensive list of the most critical web application security risks, serving as a guide for developers and security professionals. Penetration testing methodologies like PTES (Penetration Testing Execution Standard) and frameworks like Metasploit help identify and exploit vulnerabilities in controlled environments to improve security posture.</p>
   <p>Cryptography serves as the mathematical foundation of cybersecurity, providing algorithms and protocols for secure communication and data protection. Symmetric encryption algorithms like AES (Advanced Encryption Standard) use the same key for encryption and decryption, suitable for fast bulk data encryption. Asymmetric encryption systems like RSA utilize public-key cryptography, enabling secure communication between parties who have never met. Hash functions like SHA-256 create unique digital fingerprints of data, essential for password storage, digital signatures, and blockchain technology. Digital certificates and Public Key Infrastructure (PKI) establish trust relationships in distributed systems, while protocols like TLS/SSL secure web communications and email encryption protects sensitive correspondence.</p>
   <p>Ethical hacking and penetration testing provide controlled methods for discovering security vulnerabilities before malicious actors can exploit them. The ethical hacking methodology follows structured phases including reconnaissance for information gathering, scanning and enumeration to identify potential entry points, vulnerability assessment to discover security weaknesses, exploitation to demonstrate potential impact, and comprehensive reporting with remediation recommendations. Popular tools include Kali Linux as a penetration testing distribution, Burp Suite for web application testing, Metasploit for exploit development and execution, and social engineering frameworks for testing human vulnerabilities. Incident response procedures ensure rapid detection, containment, and recovery from security breaches, while digital forensics techniques help investigate cyber crimes and gather evidence for legal proceedings. Compliance frameworks like ISO 27001, NIST Cybersecurity Framework, and GDPR provide structured approaches to implementing comprehensive security programs in organizations of all sizes.</p>
 `,
 "topic9": `
   <h2 class="pt-5 lh-base mb-3">Internet of Things (IoT) & Embedded Systems</h2>
   <p>The Internet of Things represents a revolutionary paradigm where everyday objects become smart, connected devices capable of collecting, processing, and sharing data across networks. For BTech CS students, IoT offers immense opportunities to work at the intersection of hardware and software, creating intelligent systems that bridge the physical and digital worlds. The IoT ecosystem consists of interconnected devices ranging from simple sensors and actuators to complex autonomous systems, all communicating through various protocols and platforms. Understanding IoT begins with recognizing its core components: sensors that collect environmental data like temperature, humidity, motion, and light; microcontrollers and processors that execute control logic; communication modules that enable network connectivity; and cloud platforms that provide data storage, processing, and analytics capabilities. The integration of these components creates intelligent systems capable of autonomous decision-making and remote monitoring.</p>
   <p>Embedded systems form the foundation of IoT devices, requiring specialized knowledge of microcontrollers, real-time operating systems, and resource-constrained programming. Popular platforms like Arduino provide accessible entry points for beginners, offering extensive libraries and community support for rapid prototyping. Raspberry Pi brings full Linux capabilities to embedded applications, enabling complex processing and multimedia applications. ESP32 and ESP8266 modules integrate Wi-Fi and Bluetooth connectivity, making them ideal for IoT applications. Programming embedded systems requires understanding of C/C++ programming, memory management, interrupt handling, and power optimization techniques. Real-time constraints demand predictable system behavior, often requiring real-time operating systems (RTOS) like FreeRTOS or embedded Linux distributions optimized for resource-constrained environments.</p>
   <p>Communication protocols in IoT span multiple layers and technologies, each optimized for specific use cases and constraints. Short-range protocols include Bluetooth and Bluetooth Low Energy (BLE) for personal area networks, Wi-Fi for high-bandwidth local connectivity, and Zigbee for mesh networking in smart homes and industrial applications. Long-range protocols encompass cellular technologies like 4G/5G for mobile connectivity, LoRaWAN for long-range, low-power applications, and satellite communication for remote locations. MQTT (Message Queuing Telemetry Transport) provides lightweight publish-subscribe messaging for resource-constrained devices, while CoAP (Constrained Application Protocol) offers RESTful communication optimized for IoT. HTTP/HTTPS remains popular for web-based IoT applications, and WebSocket enables real-time bidirectional communication between devices and web applications.</p>
   <p>IoT platforms and cloud services provide the infrastructure for managing large-scale deployments, offering device management, data processing, and analytics capabilities. Amazon Web Services IoT Core provides secure device connectivity and messaging, while Microsoft Azure IoT Hub offers comprehensive device management and edge computing capabilities. Google Cloud IoT Platform integrates with machine learning services for intelligent data processing, and IBM Watson IoT provides industry-specific solutions. Edge computing brings processing power closer to IoT devices, reducing latency and bandwidth requirements while enabling real-time decision-making. Edge devices can perform local data filtering, aggregation, and basic analytics before sending processed information to cloud platforms, optimizing network usage and improving system responsiveness.</p>
   <p>Security challenges in IoT require comprehensive approaches addressing device-level, network-level, and application-level threats. Device security involves secure boot processes, encrypted firmware updates, and hardware security modules for cryptographic operations. Network security encompasses secure communication protocols, VPN connections, and network segmentation to isolate IoT devices from critical systems. Data privacy and protection become paramount when dealing with personal information collected by smart devices, requiring compliance with regulations like GDPR and CCPA. Industrial IoT (IIoT) applications in manufacturing, energy, and transportation require additional security measures due to potential impacts on physical systems and human safety. Smart city applications integrate multiple IoT systems for traffic management, environmental monitoring, and public safety, while smart agriculture uses IoT sensors and automation to optimize crop yields and resource usage. Healthcare IoT enables remote patient monitoring, medication management, and emergency response systems, transforming how medical care is delivered and monitored.</p>
 `,
 "topic10": `
   <h2 class="pt-5 lh-base mb-3">Computer Graphics & Game Development</h2>
   <p>Computer Graphics and Game Development represent one of the most creative and technically challenging areas of computer science, combining mathematical precision with artistic vision to create immersive visual experiences. For BTech CS students, this field offers opportunities to work on cutting-edge technologies including real-time rendering, virtual reality, augmented reality, and interactive entertainment systems. The foundation of computer graphics lies in understanding coordinate systems, transformations, and the mathematics of 3D space. Linear algebra becomes essential for manipulating objects in 3D space through transformation matrices, while vector mathematics enables calculations for lighting, collision detection, and physics simulations. The graphics pipeline transforms 3D models into 2D images through vertex processing, primitive assembly, rasterization, and fragment processing, with modern GPUs accelerating these operations through parallel processing architectures.</p>
   <p>Rendering techniques determine how 3D scenes are converted into realistic images, with different approaches optimized for various applications and performance requirements. Rasterization, the most common real-time rendering technique, projects 3D triangles onto 2D screen space and fills pixels based on depth testing and color interpolation. Ray tracing provides photorealistic rendering by simulating light paths from camera to light sources, enabling accurate reflections, refractions, and global illumination effects. Path tracing extends ray tracing with advanced sampling techniques for even more realistic lighting, while real-time ray tracing on modern GPUs like RTX series brings cinematic quality to interactive applications. Shading models including Phong, Blinn-Phong, and physically-based rendering (PBR) calculate surface appearance based on material properties and lighting conditions, with shader programming languages like HLSL and GLSL enabling custom visual effects.</p>
   <p>Game engines provide comprehensive frameworks for game development, offering tools for rendering, physics simulation, audio processing, input handling, and asset management. Unity dominates indie and mobile game development with its user-friendly interface, extensive asset store, and cross-platform deployment capabilities. Unreal Engine leads in AAA game development with advanced rendering capabilities, sophisticated blueprint visual scripting, and industry-standard tools for large-scale productions. Godot offers open-source game development with a unique scene system and GDScript programming language, while specialized engines like GameMaker Studio focus on 2D game development. Understanding engine architecture enables developers to choose appropriate tools and optimize performance for specific project requirements.</p>
   <p>Game programming encompasses multiple specialized disciplines including gameplay programming for game mechanics and rules, graphics programming for rendering optimizations and visual effects, engine programming for core systems development, and tools programming for content creation pipelines. Programming languages vary by platform and engine, with C++ dominating performance-critical applications, C# popular in Unity development, and scripting languages like Lua and Python used for gameplay logic. Design patterns like Entity-Component-System (ECS) architectures optimize performance and flexibility in complex game systems, while state machines manage character behaviors and game flow. Multiplayer programming introduces additional challenges including network synchronization, lag compensation, and server architecture design for supporting thousands of concurrent players.</p>
   <p>Specialized areas within computer graphics continue expanding with emerging technologies and applications. Virtual Reality (VR) development requires understanding of stereoscopic rendering, motion tracking, and user interaction in 3D space, with platforms like Oculus, SteamVR, and PlayStation VR each offering unique capabilities and constraints. Augmented Reality (AR) overlays digital content onto real-world environments, requiring computer vision techniques for tracking and mapping, with frameworks like ARKit, ARCore, and Vuforia providing development platforms. Procedural generation creates vast game worlds and content through algorithmic techniques, enabling infinite exploration and reducing manual content creation costs. Computer animation involves keyframe animation, skeletal animation systems, and motion capture integration for realistic character movement. Real-time visual effects simulate natural phenomena like fire, water, smoke, and particle systems, while post-processing effects add cinematic quality through techniques like bloom, depth of field, and color grading. The gaming industry continues evolving with cloud gaming, mobile platforms, and emerging technologies like AI-driven content generation, creating new opportunities for computer graphics professionals.</p>
 `
};


topicList.addEventListener("click", async (e) => {
  const clicked = e.target.closest(".topic");
  if (!clicked) return;

  document.querySelectorAll(".topic").forEach((el) => el.classList.remove("active"));
  clicked.classList.add("active");

  const topicKey = clicked.dataset.topic;

 if (topicKey === "new-chat") {
    const res = await fetch("/pages/chat.html");
    const html = await res.text();
    content.innerHTML = html;

    // ✅ Remove previous Chat.js script if it exists
    const oldScript = document.querySelector('script[src="/pages/Chat.js"]');
    if (oldScript) {
      console.log("🧹 Removing existing Chat.js script");
      oldScript.remove();
    }

    // ✅ Clear previous chat globals if any
    if (window.ChatApp && window.ChatApp.socket) {
      window.ChatApp.socket.disconnect();
    }
    delete window.ChatApp;
    delete window.ChatGlobals;
    delete window.initChatApp;
    delete window.openImageModal;
    delete window.closeImageModal;

    // ✅ Add fresh Chat.js script with better error handling
    const script = document.createElement("script");
    script.src = "/pages/Chat.js";
    script.onload = () => {
      console.log("✅ Chat.js loaded successfully");
      
      // Wait a bit for the script to fully initialize
      setTimeout(() => {
        if (typeof window.initChatApp === "function") {
          window.initChatApp().catch(err => {
            console.error("❌ Error initializing chat app:", err);
          });
        } else {
          console.error("❌ initChatApp is not available");
        }
      }, 100);
    };
    script.onerror = () => console.error("❌ Failed to load Chat.js");
    content.appendChild(script);
  } else {
    content.innerHTML = topics[topicKey] || "<p>No content found.</p>";
  }
});

function logout() {
  localStorage.removeItem("token");
  window.location.href = "index.html";
}
